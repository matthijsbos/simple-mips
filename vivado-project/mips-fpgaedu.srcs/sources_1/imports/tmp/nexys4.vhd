-- File: ./nexys4.vhd
-- Generated by MyHDL 0.9.0
-- Date: Sun Oct 23 20:09:23 2016


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;


Library UNISIM;
use UNISIM.vcomponents.all;

use work.pck_myhdl_090.all;


entity nexys4 is
    port (
        clk: in std_logic;
        reset: in std_logic;
        rx: in std_logic;
        tx: out std_logic;
        exp_addr: out std_logic_vector(31 downto 0);
        exp_data_write: out std_logic_vector(31 downto 0);
        exp_data_read: in std_logic_vector(31 downto 0);
        exp_wen: out std_logic;
        exp_reset: out std_logic;
        exp_clk: out std_logic;
        exp_clk_en: out std_logic
    );
end entity nexys4;


architecture MyHDL of nexys4 is


constant spec_opcode_res_start_success: integer := 7;
constant reset_active: integer := 0;
constant spec_opcode_res_write_error_mode: integer := 3;
constant spec_opcode_res_pause_error_mode: integer := 10;
constant spec_opcode_res_status: integer := 11;
constant spec_index_opcode_high: integer := 67;
constant spec_index_value_high: integer := 2**6-1;
constant spec_index_addr_high: integer := 2**6-1;
constant LVL_STOP: integer := 1;
constant spec_chr_start: integer := 18;
constant spec_opcode_cmd_reset: integer := 2;
constant spec_opcode_res_read_error_mode: integer := 1;
constant spec_index_data_high: integer := 2**5-1;
constant spec_opcode_cmd_status: integer := 6;
constant spec_opcode_res_reset_success: integer := 4;
constant spec_opcode_res_step_success: integer := 5;
constant spec_opcode_res_pause_success: integer := 9;
constant stop_bits: integer := 1;
constant spec_opcode_res_step_error_mode: integer := 6;
constant spec_opcode_cmd_step: integer := 3;
constant spec_opcode_cmd_pause: integer := 5;
constant LVL_START: integer := 0;
constant spec_chr_esc: integer := 125;
constant rx_div: integer := 8;
constant data_bits: integer := 8;
constant LVL_IDLE: integer := 1;
constant exp_reset_active: integer := 1;
constant spec_opcode_cmd_start: integer := 4;
constant spec_width_message_bytes: integer := 9;
constant spec_index_value_low: integer := 0;
constant spec_opcode_cmd_read: integer := 0;
constant spec_opcode_cmd_write: integer := 1;
constant spec_opcode_res_start_error_mode: integer := 8;
constant spec_opcode_res_read_success: integer := 0;
constant spec_index_opcode_low: integer := 2**6;
constant spec_index_addr_low: integer := 2**5;
constant tx_tick_max: integer := 10416;
constant depth: integer := 12;
constant spec_opcode_res_write_success: integer := 2;
constant spec_chr_stop: integer := 19;
constant spec_width_message: integer := 68;
constant spec_index_data_low: integer := 0;


type t_enum_state_t_1 is (
    MANUAL,
    AUTONOMOUS
);
type t_enum_state_t_2 is (
    WAIT_START,
    RECV_START,
    RECV_DATA,
    RECV_STOP
);
type t_enum_state_t_3 is (
    READ_START,
    READ_DATA,
    READ_STOP,
    READY
);
type t_enum_state_t_4 is (
    READY,
    WAIT_START,
    SEND_START,
    SEND_DATA,
    SEND_STOP
);
type t_enum_state_t_5 is (
    IDLE,
    TRANSMIT_START,
    TRANSMIT_STOP,
    TRANSMIT_DATA
);

signal exp_addr_num: unsigned(31 downto 0);
signal message_rx_data: unsigned(67 downto 0);
signal rx_baud_tick: std_logic;
signal message_rx_ready: std_logic;
signal message_tx_trans_next: std_logic;
signal exp_clk_en_internal: std_logic;
signal tx_baud_tick: std_logic;
signal message_tx_ready: std_logic;
signal message_tx_data: unsigned(67 downto 0);
signal exp_data_write_num: unsigned(31 downto 0);
signal message_rx_recv_next: std_logic;
signal exp_data_read_num: unsigned(31 downto 0);
signal baudgen_tick_count_reg: unsigned(13 downto 0);
signal baudgen_rx_div_count_next: unsigned(2 downto 0);
signal baudgen_tick_count_next: unsigned(13 downto 0);
signal baudgen_rx_tick_lookup_rom_dout: unsigned(13 downto 0);
signal baudgen_rx_div_count_reg: unsigned(2 downto 0);
signal component_tx_uart_tx_start: std_logic;
signal component_tx_uart_tx_busy: std_logic;
signal component_tx_uart_tx_data: unsigned(7 downto 0);
signal component_tx_transmitter_byte_count_reg: unsigned(3 downto 0);
signal component_tx_transmitter_dout: unsigned(7 downto 0);
signal component_tx_transmitter_byte_count_next: unsigned(3 downto 0);
signal component_tx_transmitter_prev_esc_reg: std_logic;
signal component_tx_transmitter_prev_esc_next: std_logic;
signal component_tx_transmitter_esc: std_logic;
signal component_tx_transmitter_index_low: unsigned(6 downto 0);
signal component_tx_transmitter_state_next: t_enum_state_t_5;
signal component_tx_transmitter_state_reg: t_enum_state_t_5;
signal component_tx_transmitter_message_reg: unsigned(71 downto 0);
signal component_tx_transmitter_message_next: unsigned(71 downto 0);
signal component_tx_uart_tx_data_next: unsigned(7 downto 0);
signal component_tx_uart_tx_count_reg: unsigned(2 downto 0);
signal component_tx_uart_tx_data_reg: unsigned(7 downto 0);
signal component_tx_uart_tx_count_next: unsigned(2 downto 0);
signal component_tx_uart_tx_state_next: t_enum_state_t_4;
signal component_tx_uart_tx_state_reg: t_enum_state_t_4;
signal component_rx_fifo_rx_dout: unsigned(7 downto 0);
signal component_rx_uart_rx_busy: std_logic;
signal component_rx_fifo_rx_empty: std_logic;
signal component_rx_fifo_rx_full: std_logic;
signal component_rx_fifo_rx_dequeue: std_logic;
signal component_rx_uart_rx_data: unsigned(7 downto 0);
signal component_rx_uart_rx_finish: std_logic;
signal component_rx_receiver_byte_count_reg: unsigned(3 downto 0);
signal component_rx_receiver_byte_count_next: unsigned(3 downto 0);
signal component_rx_receiver_esc_reg: std_logic;
signal component_rx_receiver_index_low: unsigned(6 downto 0);
signal component_rx_receiver_state_reg: t_enum_state_t_3;
signal component_rx_receiver_esc_next: std_logic;
signal component_rx_receiver_state_next: t_enum_state_t_3;
signal component_rx_receiver_message_reg: unsigned(71 downto 0);
signal component_rx_receiver_message_next: unsigned(71 downto 0);
signal component_rx_fifo_rx_count_next: unsigned(3 downto 0);
signal component_rx_fifo_rx_count_reg: unsigned(3 downto 0);
signal component_rx_fifo_rx_oldest_addr_reg: unsigned(3 downto 0);
signal component_rx_fifo_rx_oldest_addr_next: unsigned(3 downto 0);
signal component_rx_uart_rx_baud_count_reg: unsigned(2 downto 0);
signal component_rx_uart_rx_data_reg: unsigned(7 downto 0);
signal component_rx_uart_rx_baud_count_next: unsigned(2 downto 0);
signal component_rx_uart_rx_data_count_next: unsigned(2 downto 0);
signal component_rx_uart_rx_data_count_reg: unsigned(2 downto 0);
signal component_rx_uart_rx_data_next: unsigned(7 downto 0);
signal component_rx_uart_rx_state_next: t_enum_state_t_2;
signal component_rx_uart_rx_state_reg: t_enum_state_t_2;
signal controller_ex_res_addr_reg: unsigned(31 downto 0);
signal controller_cycle_pause: std_logic;
signal controller_ex_res_nop_reg: std_logic;
signal controller_ex_res_nop_next: std_logic;
signal controller_ex_res_opcode_res_reg: unsigned(3 downto 0);
signal controller_cmd_data: unsigned(31 downto 0);
signal controller_cmd_addr: unsigned(31 downto 0);
signal controller_cycle_autonomous: std_logic;
signal controller_cmd_opcode: unsigned(3 downto 0);
signal controller_cycle_step: std_logic;
signal controller_ex_res_opcode_res_next: unsigned(3 downto 0);
signal controller_ex_res_cycle_count_reg: unsigned(63 downto 0);
signal controller_ex_res_cycle_count_next: unsigned(63 downto 0);
signal controller_ex_res_addr_next: unsigned(31 downto 0);
signal controller_cycle_start: std_logic;
signal controller_cycle_control_state_next: t_enum_state_t_1;
signal controller_cycle_control_cycle_count_next: unsigned(63 downto 0);
signal controller_cycle_control_cycle_count_reg: unsigned(63 downto 0);
signal controller_cycle_control_exp_clk_en_reg: std_logic;
signal controller_cycle_control_state_reg: t_enum_state_t_1;
signal controller_cycle_control_exp_clk_en_next: std_logic;
signal controller_control_nop_int: std_logic;
type t_array_component_rx_fifo_rx_mem is array(0 to 12-1) of unsigned(7 downto 0);
signal component_rx_fifo_rx_mem: t_array_component_rx_fifo_rx_mem;

begin

exp_addr <= std_logic_vector(exp_addr_num);
exp_data_write <= std_logic_vector(exp_data_write_num);
exp_data_read_num <= unsigned(exp_data_read);





controller_control_nop_int <= stdl((not bool(message_rx_ready)) or (not bool(message_tx_ready)) or (reset = '0'));


NEXYS4_CONTROLLER_CONTROL_OUTPUT_LOGIC: process (reset, controller_cmd_opcode, controller_control_nop_int, controller_cycle_autonomous) is
begin
    message_rx_recv_next <= stdl((not bool(controller_control_nop_int)));
    controller_ex_res_nop_next <= controller_control_nop_int;
    exp_wen <= stdl((controller_cmd_opcode = spec_opcode_cmd_write) and (not bool(controller_cycle_autonomous)) and (not bool(controller_control_nop_int)) and (reset /= '0'));
    if ((reset = '0') or ((controller_cmd_opcode = spec_opcode_cmd_reset) and (not bool(controller_control_nop_int)))) then
        exp_reset <= '1';
    else
        exp_reset <= stdl((not bool(exp_reset_active)));
    end if;
    controller_ex_res_opcode_res_next <= to_unsigned(0, 4);
    if (reset = '0') then
        controller_ex_res_opcode_res_next <= to_unsigned(0, 4);
    end if;
    if ((controller_cmd_opcode = spec_opcode_cmd_read) and (not bool(controller_cycle_autonomous))) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_read_success, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_read) and bool(controller_cycle_autonomous)) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_read_error_mode, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_write) and (not bool(controller_cycle_autonomous))) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_write_success, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_write) and bool(controller_cycle_autonomous)) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_write_error_mode, 4);
    elsif (controller_cmd_opcode = spec_opcode_cmd_reset) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_reset_success, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_step) and (not bool(controller_cycle_autonomous))) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_step_success, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_step) and bool(controller_cycle_autonomous)) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_step_error_mode, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_start) and (not bool(controller_cycle_autonomous))) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_start_success, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_start) and bool(controller_cycle_autonomous)) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_start_error_mode, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_pause) and bool(controller_cycle_autonomous)) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_pause_success, 4);
    elsif ((controller_cmd_opcode = spec_opcode_cmd_pause) and (not bool(controller_cycle_autonomous))) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_pause_error_mode, 4);
    elsif (controller_cmd_opcode = spec_opcode_cmd_status) then
        controller_ex_res_opcode_res_next <= to_unsigned(spec_opcode_res_status, 4);
    end if;
    controller_cycle_start <= stdl((controller_cmd_opcode = spec_opcode_cmd_start) and (not bool(controller_cycle_autonomous)) and (not bool(controller_control_nop_int)) and (reset /= '0'));
    controller_cycle_pause <= stdl((controller_cmd_opcode = spec_opcode_cmd_pause) and bool(controller_cycle_autonomous) and (not bool(controller_control_nop_int)) and (reset /= '0'));
    controller_cycle_step <= stdl((controller_cmd_opcode = spec_opcode_cmd_step) and (not bool(controller_cycle_autonomous)) and (not bool(controller_control_nop_int)) and (reset /= '0'));
end process NEXYS4_CONTROLLER_CONTROL_OUTPUT_LOGIC;


NEXYS4_CONTROLLER_CYCLE_CONTROL_REGISTER_LOGIC: process (clk) is
begin
    if falling_edge(clk) then
        if (reset = '0') then
            controller_cycle_control_exp_clk_en_reg <= '0';
            controller_cycle_control_state_reg <= MANUAL;
            controller_cycle_control_cycle_count_reg <= to_unsigned(0, 64);
        else
            controller_cycle_control_state_reg <= controller_cycle_control_state_next;
            controller_cycle_control_cycle_count_reg <= controller_cycle_control_cycle_count_next;
            controller_cycle_control_exp_clk_en_reg <= controller_cycle_control_exp_clk_en_next;
        end if;
    end if;
end process NEXYS4_CONTROLLER_CYCLE_CONTROL_REGISTER_LOGIC;


NEXYS4_CONTROLLER_CYCLE_CONTROL_NEXT_STATE_LOGIC: process (controller_cycle_start, controller_cycle_step, controller_cycle_pause, controller_cycle_control_state_reg, controller_cycle_control_cycle_count_reg) is
begin
    controller_cycle_control_state_next <= controller_cycle_control_state_reg;
    controller_cycle_control_cycle_count_next <= controller_cycle_control_cycle_count_reg;
    controller_cycle_control_exp_clk_en_next <= '0';
    case controller_cycle_control_state_reg is
        when MANUAL =>
            if bool(controller_cycle_step) then
                controller_cycle_control_cycle_count_next <= (controller_cycle_control_cycle_count_reg + 1);
                controller_cycle_control_exp_clk_en_next <= '1';
            elsif bool(controller_cycle_start) then
                controller_cycle_control_cycle_count_next <= (controller_cycle_control_cycle_count_reg + 1);
                controller_cycle_control_state_next <= AUTONOMOUS;
                controller_cycle_control_exp_clk_en_next <= '1';
            end if;
        when others => -- AUTONOMOUS
            if bool(controller_cycle_pause) then
                controller_cycle_control_exp_clk_en_next <= '0';
                controller_cycle_control_state_next <= MANUAL;
            else
                controller_cycle_control_exp_clk_en_next <= '1';
                controller_cycle_control_cycle_count_next <= (controller_cycle_control_cycle_count_reg + 1);
            end if;
    end case;
end process NEXYS4_CONTROLLER_CYCLE_CONTROL_NEXT_STATE_LOGIC;



controller_cycle_autonomous <= stdl(controller_cycle_control_state_reg = AUTONOMOUS);
controller_ex_res_cycle_count_next <= controller_cycle_control_cycle_count_reg;
exp_clk_en_internal <= controller_cycle_control_exp_clk_en_reg;


NEXYS4_CONTROLLER_RES_COMPOSE_OUTPUT_LOGIC: process (controller_ex_res_opcode_res_reg, controller_ex_res_addr_reg, controller_ex_res_nop_reg, message_tx_ready, exp_data_read_num, controller_ex_res_cycle_count_reg) is
begin
    message_tx_trans_next <= '0';
    message_tx_data <= to_unsigned(0, 68);
    if (bool(message_tx_ready) and (not bool(controller_ex_res_nop_reg))) then
        message_tx_trans_next <= '1';
    end if;
    message_tx_data((spec_index_opcode_high + 1)-1 downto spec_index_opcode_low) <= controller_ex_res_opcode_res_reg;
    if ((controller_ex_res_opcode_res_reg = spec_opcode_res_read_success) or (controller_ex_res_opcode_res_reg = spec_opcode_res_write_success)) then
        message_tx_data((spec_index_addr_high + 1)-1 downto spec_index_addr_low) <= controller_ex_res_addr_reg;
        message_tx_data((spec_index_data_high + 1)-1 downto spec_index_data_low) <= exp_data_read_num;
    elsif ((controller_ex_res_opcode_res_reg = spec_opcode_res_read_error_mode) or (controller_ex_res_opcode_res_reg = spec_opcode_res_write_error_mode)) then
        message_tx_data((spec_index_addr_high + 1)-1 downto spec_index_addr_low) <= controller_ex_res_addr_reg;
        message_tx_data((spec_index_data_high + 1)-1 downto spec_index_data_low) <= to_unsigned(0, 32);
    elsif (controller_ex_res_opcode_res_reg = spec_opcode_res_step_success) then
        message_tx_data((spec_index_value_high + 1)-1 downto spec_index_value_low) <= (controller_ex_res_cycle_count_reg + 1);
    elsif ((controller_ex_res_opcode_res_reg = spec_opcode_res_start_success) or (controller_ex_res_opcode_res_reg = spec_opcode_res_pause_success) or (controller_ex_res_opcode_res_reg = spec_opcode_res_status)) then
        message_tx_data((spec_index_value_high + 1)-1 downto spec_index_value_low) <= controller_ex_res_cycle_count_reg;
    else
        message_tx_data((spec_index_value_high + 1)-1 downto spec_index_value_low) <= to_unsigned(0, 64);
    end if;
end process NEXYS4_CONTROLLER_RES_COMPOSE_OUTPUT_LOGIC;



controller_cmd_opcode <= message_rx_data((spec_index_opcode_high + 1)-1 downto spec_index_opcode_low);
controller_cmd_addr <= message_rx_data((spec_index_addr_high + 1)-1 downto spec_index_addr_low);
controller_cmd_data <= message_rx_data((spec_index_data_high + 1)-1 downto spec_index_data_low);



exp_addr_num <= controller_cmd_addr;
exp_data_write_num <= controller_cmd_data;


NEXYS4_CONTROLLER_PIPELINE_REGISTER_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '0') then
            controller_ex_res_opcode_res_reg <= to_unsigned(0, 4);
            controller_ex_res_nop_reg <= '1';
            controller_ex_res_addr_reg <= to_unsigned(0, 32);
            controller_ex_res_cycle_count_reg <= to_unsigned(0, 64);
        else
            controller_ex_res_opcode_res_reg <= controller_ex_res_opcode_res_next;
            controller_ex_res_nop_reg <= controller_ex_res_nop_next;
            controller_ex_res_cycle_count_reg <= controller_ex_res_cycle_count_next;
            controller_ex_res_addr_reg <= controller_ex_res_addr_next;
        end if;
    end if;
end process NEXYS4_CONTROLLER_PIPELINE_REGISTER_LOGIC;



controller_ex_res_addr_next <= controller_cmd_addr;


NEXYS4_BAUDGEN_REG_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '0') then
            baudgen_tick_count_reg <= to_unsigned(0, 14);
            baudgen_rx_div_count_reg <= to_unsigned(0, 3);
        else
            baudgen_tick_count_reg <= baudgen_tick_count_next;
            baudgen_rx_div_count_reg <= baudgen_rx_div_count_next;
        end if;
    end if;
end process NEXYS4_BAUDGEN_REG_LOGIC;


NEXYS4_BAUDGEN_NEXT_STATE_LOGIC: process (baudgen_tick_count_reg, baudgen_rx_tick_lookup_rom_dout, baudgen_rx_div_count_reg) is
begin
    baudgen_tick_count_next <= ((baudgen_tick_count_reg + 1) mod tx_tick_max);
    if (baudgen_tick_count_reg = baudgen_rx_tick_lookup_rom_dout) then
        baudgen_rx_div_count_next <= ((baudgen_rx_div_count_reg + 1) mod rx_div);
    else
        baudgen_rx_div_count_next <= baudgen_rx_div_count_reg;
    end if;
end process NEXYS4_BAUDGEN_NEXT_STATE_LOGIC;


NEXYS4_BAUDGEN_OUTPUT_LOGIC: process (baudgen_tick_count_reg, baudgen_rx_tick_lookup_rom_dout) is
begin
    if (baudgen_tick_count_reg = baudgen_rx_tick_lookup_rom_dout) then
        rx_baud_tick <= '1';
    else
        rx_baud_tick <= '0';
    end if;
    if (signed(resize(baudgen_tick_count_reg, 15)) = (tx_tick_max - 1)) then
        tx_baud_tick <= '1';
    else
        tx_baud_tick <= '0';
    end if;
end process NEXYS4_BAUDGEN_OUTPUT_LOGIC;


NEXYS4_BAUDGEN_RX_TICK_LOOKUP_ROM_READ: process (baudgen_rx_div_count_reg) is
begin
    case to_integer(baudgen_rx_div_count_reg) is
        when 0 => baudgen_rx_tick_lookup_rom_dout <= "00010100010101";
        when 1 => baudgen_rx_tick_lookup_rom_dout <= "00101000101011";
        when 2 => baudgen_rx_tick_lookup_rom_dout <= "00111101000001";
        when 3 => baudgen_rx_tick_lookup_rom_dout <= "01010001010111";
        when 4 => baudgen_rx_tick_lookup_rom_dout <= "01100101101101";
        when 5 => baudgen_rx_tick_lookup_rom_dout <= "01111010000011";
        when 6 => baudgen_rx_tick_lookup_rom_dout <= "10001110011001";
        when others => baudgen_rx_tick_lookup_rom_dout <= "10100010101111";
    end case;
end process NEXYS4_BAUDGEN_RX_TICK_LOOKUP_ROM_READ;



-- BUFGCE: Global Clock Buffer with Clock Enable
-- 7 Series
-- Xilinx HDL Libraries Guide, version 14.7
BUFGCE_inst : BUFGCE
port map (
        O => exp_clk,   -- 1-bit output: Clock output
        CE => exp_clk_en_internal, -- 1-bit input: Clock enable input for I0
        I => clk    -- 1-bit input: Primary clock
        );
-- End of BUFGCE_inst instantiation


NEXYS4_COMPONENT_RX_UART_RX_REGISTER_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '0') then
            component_rx_uart_rx_baud_count_reg <= to_unsigned(0, 3);
            component_rx_uart_rx_data_reg <= to_unsigned(0, 8);
            component_rx_uart_rx_state_reg <= WAIT_START;
            component_rx_uart_rx_data_count_reg <= to_unsigned(0, 3);
        else
            component_rx_uart_rx_state_reg <= component_rx_uart_rx_state_next;
            component_rx_uart_rx_baud_count_reg <= component_rx_uart_rx_baud_count_next;
            component_rx_uart_rx_data_count_reg <= component_rx_uart_rx_data_count_next;
            component_rx_uart_rx_data_reg <= component_rx_uart_rx_data_next;
        end if;
    end if;
end process NEXYS4_COMPONENT_RX_UART_RX_REGISTER_LOGIC;

-- Determine next state levels for registers state_reg, baud_count_reg,
-- data_count_reg and data_reg based on current state and input signals
NEXYS4_COMPONENT_RX_UART_RX_NEXT_STATE_LOGIC: process (component_rx_uart_rx_baud_count_reg, rx, component_rx_uart_rx_data_count_reg, rx_baud_tick, component_rx_uart_rx_data_reg, component_rx_uart_rx_state_reg) is
begin
    component_rx_uart_rx_finish <= '0';
    component_rx_uart_rx_data <= to_unsigned(0, 8);
    component_rx_uart_rx_state_next <= component_rx_uart_rx_state_reg;
    component_rx_uart_rx_baud_count_next <= component_rx_uart_rx_baud_count_reg;
    component_rx_uart_rx_data_next <= component_rx_uart_rx_data_reg;
    component_rx_uart_rx_data_count_next <= component_rx_uart_rx_data_count_reg;
    case component_rx_uart_rx_state_reg is
        when WAIT_START =>
            component_rx_uart_rx_data_next <= to_unsigned(0, 8);
            if ((rx = '0') and (rx_baud_tick = '1')) then
                component_rx_uart_rx_state_next <= RECV_START;
            end if;
        when RECV_START =>
            if (rx_baud_tick = '1') then
                component_rx_uart_rx_baud_count_next <= resize(unsigned(signed(resize(component_rx_uart_rx_baud_count_reg, 4) + 1) mod (rx_div / 2)), 3);
                if (signed(resize(component_rx_uart_rx_baud_count_reg, 4)) = ((rx_div / 2) - 1)) then
                    component_rx_uart_rx_state_next <= RECV_DATA;
                end if;
            end if;
        when RECV_DATA =>
            if (rx_baud_tick = '1') then
                component_rx_uart_rx_baud_count_next <= ((component_rx_uart_rx_baud_count_reg + 1) mod rx_div);
                if (signed(resize(component_rx_uart_rx_baud_count_reg, 4)) = (rx_div - 1)) then
                    component_rx_uart_rx_data_count_next <= ((component_rx_uart_rx_data_count_reg + 1) mod data_bits);
                    component_rx_uart_rx_data_next(to_integer(component_rx_uart_rx_data_count_reg)) <= rx;
                    if (signed(resize(component_rx_uart_rx_data_count_reg, 4)) = (data_bits - 1)) then
                        component_rx_uart_rx_state_next <= RECV_STOP;
                    end if;
                end if;
            end if;
        when others => -- RECV_STOP
            if (rx_baud_tick = '1') then
                component_rx_uart_rx_baud_count_next <= ((component_rx_uart_rx_baud_count_reg + 1) mod rx_div);
            end if;
            if (signed(resize(component_rx_uart_rx_baud_count_reg, 4)) = (rx_div - 1)) then
                component_rx_uart_rx_state_next <= WAIT_START;
                if (rx = '1') then
                    component_rx_uart_rx_data <= component_rx_uart_rx_data_reg;
                    component_rx_uart_rx_finish <= '1';
                end if;
            end if;
    end case;
end process NEXYS4_COMPONENT_RX_UART_RX_NEXT_STATE_LOGIC;

-- Determine levels for output signals rx_data, rx_finish, rx_busy based
-- on input signals and current register states 
NEXYS4_COMPONENT_RX_UART_RX_OUTPUT_LOGIC: process (component_rx_uart_rx_state_reg) is
begin
    if (component_rx_uart_rx_state_reg = WAIT_START) then
        component_rx_uart_rx_busy <= '0';
    else
        component_rx_uart_rx_busy <= '1';
    end if;
end process NEXYS4_COMPONENT_RX_UART_RX_OUTPUT_LOGIC;


NEXYS4_COMPONENT_RX_FIFO_RX_REGISTER_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '0') then
            component_rx_fifo_rx_mem(0) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(1) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(2) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(3) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(4) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(5) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(6) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(7) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(8) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(9) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(10) <= to_unsigned(0, 8);
            component_rx_fifo_rx_mem(11) <= to_unsigned(0, 8);
            component_rx_fifo_rx_count_next <= to_unsigned(0, 4);
            component_rx_fifo_rx_oldest_addr_next <= to_unsigned(0, 4);
            component_rx_fifo_rx_oldest_addr_reg <= to_unsigned(0, 4);
            component_rx_fifo_rx_count_reg <= to_unsigned(0, 4);
        else
            component_rx_fifo_rx_oldest_addr_reg <= component_rx_fifo_rx_oldest_addr_next;
            component_rx_fifo_rx_count_reg <= component_rx_fifo_rx_count_next;
            if bool(component_rx_fifo_rx_dequeue) then
                component_rx_fifo_rx_oldest_addr_next <= ((component_rx_fifo_rx_oldest_addr_reg + 1) mod depth);
            else
                component_rx_fifo_rx_oldest_addr_next <= component_rx_fifo_rx_oldest_addr_reg;
            end if;
            if (bool(component_rx_uart_rx_finish) and (not bool(component_rx_fifo_rx_dequeue))) then
                if (not (component_rx_fifo_rx_count_reg = depth)) then
                    component_rx_fifo_rx_count_next <= (component_rx_fifo_rx_count_reg + 1);
                    component_rx_fifo_rx_mem(to_integer((component_rx_fifo_rx_oldest_addr_reg + component_rx_fifo_rx_count_reg) mod depth)) <= component_rx_uart_rx_data;
                end if;
            elsif ((not bool(component_rx_uart_rx_finish)) and bool(component_rx_fifo_rx_dequeue)) then
                if (component_rx_fifo_rx_count_reg = 0) then
                    component_rx_fifo_rx_count_next <= component_rx_fifo_rx_count_reg;
                else
                    component_rx_fifo_rx_count_next <= (component_rx_fifo_rx_count_reg - 1);
                end if;
            else
                component_rx_fifo_rx_count_next <= component_rx_fifo_rx_count_reg;
            end if;
        end if;
    end if;
end process NEXYS4_COMPONENT_RX_FIFO_RX_REGISTER_LOGIC;


NEXYS4_COMPONENT_RX_FIFO_RX_OUTPUT_LOGIC: process (component_rx_fifo_rx_mem, component_rx_fifo_rx_oldest_addr_reg, component_rx_fifo_rx_count_reg) is
begin
    component_rx_fifo_rx_empty <= '0';
    component_rx_fifo_rx_full <= '0';
    if (component_rx_fifo_rx_count_reg = 0) then
        component_rx_fifo_rx_dout <= to_unsigned(0, 8);
    else
        component_rx_fifo_rx_dout <= component_rx_fifo_rx_mem(to_integer(component_rx_fifo_rx_oldest_addr_reg));
    end if;
    if (component_rx_fifo_rx_count_reg = 0) then
        component_rx_fifo_rx_empty <= '1';
    elsif (component_rx_fifo_rx_count_reg = depth) then
        component_rx_fifo_rx_full <= '1';
    end if;
end process NEXYS4_COMPONENT_RX_FIFO_RX_OUTPUT_LOGIC;


NEXYS4_COMPONENT_RX_RECEIVER_REGISTER_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '0') then
            component_rx_receiver_byte_count_reg <= to_unsigned(0, 4);
            component_rx_receiver_esc_reg <= '0';
            component_rx_receiver_state_reg <= READ_START;
            component_rx_receiver_message_reg <= to_unsigned(0, 72);
        else
            component_rx_receiver_state_reg <= component_rx_receiver_state_next;
            component_rx_receiver_esc_reg <= component_rx_receiver_esc_next;
            component_rx_receiver_message_reg <= component_rx_receiver_message_next;
            component_rx_receiver_byte_count_reg <= component_rx_receiver_byte_count_next;
        end if;
    end if;
end process NEXYS4_COMPONENT_RX_RECEIVER_REGISTER_LOGIC;


NEXYS4_COMPONENT_RX_RECEIVER_NEXT_STATE_LOGIC: process (component_rx_receiver_byte_count_reg, component_rx_fifo_rx_dout, message_rx_recv_next, component_rx_receiver_index_low, component_rx_receiver_message_reg, component_rx_receiver_esc_reg, component_rx_fifo_rx_empty, component_rx_receiver_state_reg) is
begin
    component_rx_receiver_state_next <= component_rx_receiver_state_reg;
    component_rx_receiver_message_next <= component_rx_receiver_message_reg;
    component_rx_receiver_byte_count_next <= component_rx_receiver_byte_count_reg;
    component_rx_receiver_esc_next <= stdl((not bool(component_rx_fifo_rx_empty)) and (component_rx_fifo_rx_dout = spec_chr_esc));
    case component_rx_receiver_state_reg is
        when READ_START =>
            if ((component_rx_fifo_rx_dout = spec_chr_start) and (not bool(component_rx_fifo_rx_empty)) and (not bool(component_rx_receiver_esc_reg))) then
                component_rx_receiver_state_next <= READ_DATA;
            end if;
        when READ_DATA =>
            if ((not bool(component_rx_receiver_esc_reg)) and (component_rx_fifo_rx_dout = spec_chr_start)) then
                component_rx_receiver_byte_count_next <= to_unsigned(0, 4);
            elsif ((not bool(component_rx_receiver_esc_reg)) and (component_rx_fifo_rx_dout = spec_chr_stop)) then
                component_rx_receiver_byte_count_next <= to_unsigned(0, 4);
                component_rx_receiver_state_next <= READ_START;
            elsif (((not bool(component_rx_receiver_esc_reg)) and (not bool(component_rx_fifo_rx_empty)) and (component_rx_fifo_rx_dout /= spec_chr_esc)) or (bool(component_rx_receiver_esc_reg) and (not bool(component_rx_fifo_rx_empty)))) then
                component_rx_receiver_byte_count_next <= ((component_rx_receiver_byte_count_reg + 1) mod spec_width_message_bytes);
                component_rx_receiver_message_next(to_integer(component_rx_receiver_index_low + 0)) <= component_rx_fifo_rx_dout(0);
                component_rx_receiver_message_next(to_integer(component_rx_receiver_index_low + 1)) <= component_rx_fifo_rx_dout(1);
                component_rx_receiver_message_next(to_integer(component_rx_receiver_index_low + 2)) <= component_rx_fifo_rx_dout(2);
                component_rx_receiver_message_next(to_integer(component_rx_receiver_index_low + 3)) <= component_rx_fifo_rx_dout(3);
                component_rx_receiver_message_next(to_integer(component_rx_receiver_index_low + 4)) <= component_rx_fifo_rx_dout(4);
                component_rx_receiver_message_next(to_integer(component_rx_receiver_index_low + 5)) <= component_rx_fifo_rx_dout(5);
                component_rx_receiver_message_next(to_integer(component_rx_receiver_index_low + 6)) <= component_rx_fifo_rx_dout(6);
                component_rx_receiver_message_next(to_integer(component_rx_receiver_index_low + 7)) <= component_rx_fifo_rx_dout(7);
                if (signed(resize(component_rx_receiver_byte_count_reg, 5)) = (spec_width_message_bytes - 1)) then
                    component_rx_receiver_state_next <= READ_STOP;
                end if;
            end if;
        when READ_STOP =>
            if ((component_rx_fifo_rx_dout = spec_chr_stop) and (not bool(component_rx_fifo_rx_empty)) and (not bool(component_rx_receiver_esc_reg))) then
                component_rx_receiver_state_next <= READY;
            end if;
        when others => -- READY
            if bool(message_rx_recv_next) then
                component_rx_receiver_state_next <= READ_START;
            end if;
    end case;
end process NEXYS4_COMPONENT_RX_RECEIVER_NEXT_STATE_LOGIC;


NEXYS4_COMPONENT_RX_RECEIVER_OUTPUT_LOGIC: process (component_rx_fifo_rx_empty, component_rx_receiver_message_reg, component_rx_receiver_state_reg) is
begin
    message_rx_data <= component_rx_receiver_message_reg(spec_width_message-1 downto 0);
    message_rx_ready <= stdl(component_rx_receiver_state_reg = READY);
    if (component_rx_receiver_state_reg = READY) then
        component_rx_fifo_rx_dequeue <= '0';
    else
        component_rx_fifo_rx_dequeue <= stdl((not bool(component_rx_fifo_rx_empty)));
    end if;
end process NEXYS4_COMPONENT_RX_RECEIVER_OUTPUT_LOGIC;



component_rx_receiver_index_low <= resize(unsigned(((8 * spec_width_message_bytes) - signed(resize(resize(component_rx_receiver_byte_count_reg, 5) * 8, 9))) - 8), 7);


NEXYS4_COMPONENT_TX_UART_TX_REG_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '0') then
            component_tx_uart_tx_count_reg <= to_unsigned(0, 3);
            component_tx_uart_tx_state_reg <= READY;
            component_tx_uart_tx_data_reg <= to_unsigned(0, 8);
        else
            component_tx_uart_tx_state_reg <= component_tx_uart_tx_state_next;
            component_tx_uart_tx_data_reg <= component_tx_uart_tx_data_next;
            component_tx_uart_tx_count_reg <= component_tx_uart_tx_count_next;
        end if;
    end if;
end process NEXYS4_COMPONENT_TX_UART_TX_REG_LOGIC;


NEXYS4_COMPONENT_TX_UART_TX_NEXT_STATE_LOGIC: process (component_tx_uart_tx_data, component_tx_uart_tx_count_reg, component_tx_uart_tx_data_reg, component_tx_uart_tx_start, tx_baud_tick, component_tx_uart_tx_state_reg) is
begin
    component_tx_uart_tx_state_next <= component_tx_uart_tx_state_reg;
    component_tx_uart_tx_data_next <= component_tx_uart_tx_data_reg;
    component_tx_uart_tx_count_next <= to_unsigned(0, 3);
    case component_tx_uart_tx_state_reg is
        when READY =>
            if bool(component_tx_uart_tx_start) then
                component_tx_uart_tx_state_next <= WAIT_START;
                component_tx_uart_tx_data_next <= component_tx_uart_tx_data;
            elsif (bool(component_tx_uart_tx_start) and bool(tx_baud_tick)) then
                component_tx_uart_tx_state_next <= SEND_START;
                component_tx_uart_tx_data_next <= component_tx_uart_tx_data;
            end if;
        when WAIT_START =>
            if bool(tx_baud_tick) then
                component_tx_uart_tx_state_next <= SEND_START;
            end if;
        when SEND_START =>
            if bool(tx_baud_tick) then
                component_tx_uart_tx_state_next <= SEND_DATA;
            end if;
        when SEND_DATA =>
            if bool(tx_baud_tick) then
                component_tx_uart_tx_count_next <= ((component_tx_uart_tx_count_reg + 1) mod data_bits);
                if (signed(resize(component_tx_uart_tx_count_reg, 4)) = (data_bits - 1)) then
                    component_tx_uart_tx_state_next <= SEND_STOP;
                end if;
            else
                component_tx_uart_tx_count_next <= component_tx_uart_tx_count_reg;
            end if;
        when others => -- SEND_STOP
            if bool(tx_baud_tick) then
                component_tx_uart_tx_count_next <= ((component_tx_uart_tx_count_reg + 1) mod stop_bits);
                component_tx_uart_tx_state_next <= READY;
            end if;
    end case;
end process NEXYS4_COMPONENT_TX_UART_TX_NEXT_STATE_LOGIC;


NEXYS4_COMPONENT_TX_UART_TX_OUTPUT_LOGIC: process (component_tx_uart_tx_count_reg, component_tx_uart_tx_state_reg, component_tx_uart_tx_data_reg) is
begin
    tx <= '1';
    component_tx_uart_tx_busy <= '1';
    case component_tx_uart_tx_state_reg is
        when READY =>
            component_tx_uart_tx_busy <= '0';
        when WAIT_START =>
            null;
        when SEND_START =>
            tx <= '0';
        when SEND_DATA =>
            tx <= component_tx_uart_tx_data_reg(to_integer(component_tx_uart_tx_count_reg));
        when others => -- SEND_STOP
            tx <= '1';
    end case;
end process NEXYS4_COMPONENT_TX_UART_TX_OUTPUT_LOGIC;


NEXYS4_COMPONENT_TX_TRANSMITTER_REGISTER_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '0') then
            component_tx_transmitter_prev_esc_reg <= '0';
            component_tx_transmitter_byte_count_reg <= to_unsigned(0, 4);
            component_tx_transmitter_state_reg <= IDLE;
            component_tx_transmitter_message_reg <= to_unsigned(0, 72);
        else
            component_tx_transmitter_state_reg <= component_tx_transmitter_state_next;
            component_tx_transmitter_prev_esc_reg <= component_tx_transmitter_prev_esc_next;
            component_tx_transmitter_message_reg <= component_tx_transmitter_message_next;
            component_tx_transmitter_byte_count_reg <= component_tx_transmitter_byte_count_next;
        end if;
    end if;
end process NEXYS4_COMPONENT_TX_TRANSMITTER_REGISTER_LOGIC;


NEXYS4_COMPONENT_TX_TRANSMITTER_NEXT_STATE_LOGIC: process (component_tx_transmitter_byte_count_reg, component_tx_transmitter_prev_esc_reg, message_tx_trans_next, component_tx_transmitter_message_reg, component_tx_transmitter_esc, message_tx_data, component_tx_uart_tx_busy, component_tx_transmitter_state_reg) is
begin
    component_tx_transmitter_state_next <= component_tx_transmitter_state_reg;
    component_tx_transmitter_prev_esc_next <= component_tx_transmitter_prev_esc_reg;
    component_tx_transmitter_message_next <= component_tx_transmitter_message_reg;
    component_tx_transmitter_byte_count_next <= component_tx_transmitter_byte_count_reg;
    case component_tx_transmitter_state_reg is
        when IDLE =>
            if bool(message_tx_trans_next) then
                component_tx_transmitter_state_next <= TRANSMIT_START;
                component_tx_transmitter_message_next((8 * spec_width_message_bytes)-1 downto spec_width_message) <= to_unsigned(0, 4);
                component_tx_transmitter_message_next(spec_width_message-1 downto 0) <= message_tx_data;
            end if;
        when TRANSMIT_START =>
            if (not bool(component_tx_uart_tx_busy)) then
                component_tx_transmitter_byte_count_next <= to_unsigned(0, 4);
                component_tx_transmitter_state_next <= TRANSMIT_DATA;
            end if;
        when TRANSMIT_DATA =>
            if ((not bool(component_tx_uart_tx_busy)) and bool(component_tx_transmitter_esc) and (not bool(component_tx_transmitter_prev_esc_reg))) then
                component_tx_transmitter_prev_esc_next <= '1';
            elsif ((not bool(component_tx_uart_tx_busy)) and ((not bool(component_tx_transmitter_esc)) or (bool(component_tx_transmitter_esc) and bool(component_tx_transmitter_prev_esc_reg)))) then
                component_tx_transmitter_byte_count_next <= ((component_tx_transmitter_byte_count_reg + 1) mod spec_width_message_bytes);
                component_tx_transmitter_prev_esc_next <= '0';
                if (signed(resize(component_tx_transmitter_byte_count_reg, 5)) = (spec_width_message_bytes - 1)) then
                    component_tx_transmitter_state_next <= TRANSMIT_STOP;
                end if;
            end if;
        when others => -- TRANSMIT_STOP
            if (not bool(component_tx_uart_tx_busy)) then
                component_tx_transmitter_state_next <= IDLE;
            end if;
    end case;
end process NEXYS4_COMPONENT_TX_TRANSMITTER_NEXT_STATE_LOGIC;


NEXYS4_COMPONENT_TX_TRANSMITTER_OUTPUT_LOGIC: process (component_tx_transmitter_dout, component_tx_transmitter_prev_esc_reg, component_tx_transmitter_esc, component_tx_transmitter_state_reg, component_tx_uart_tx_busy) is
begin
    component_tx_uart_tx_start <= stdl((component_tx_transmitter_state_reg /= IDLE) and (not bool(component_tx_uart_tx_busy)));
    message_tx_ready <= stdl(component_tx_transmitter_state_reg = IDLE);
    case component_tx_transmitter_state_reg is
        when IDLE =>
            component_tx_uart_tx_data <= to_unsigned(0, 8);
        when TRANSMIT_START =>
            component_tx_uart_tx_data <= to_unsigned(spec_chr_start, 8);
        when TRANSMIT_DATA =>
            if ((not bool(component_tx_transmitter_esc)) or (bool(component_tx_transmitter_esc) and bool(component_tx_transmitter_prev_esc_reg))) then
                component_tx_uart_tx_data <= component_tx_transmitter_dout;
            else
                component_tx_uart_tx_data <= to_unsigned(spec_chr_esc, 8);
            end if;
        when others => -- TRANSMIT_STOP
            component_tx_uart_tx_data <= to_unsigned(spec_chr_stop, 8);
    end case;
end process NEXYS4_COMPONENT_TX_TRANSMITTER_OUTPUT_LOGIC;


NEXYS4_COMPONENT_TX_TRANSMITTER_DOUT_LOGIC: process (component_tx_transmitter_message_reg, component_tx_transmitter_index_low) is
begin
    component_tx_transmitter_dout(0) <= component_tx_transmitter_message_reg(to_integer(component_tx_transmitter_index_low + 0));
    component_tx_transmitter_dout(1) <= component_tx_transmitter_message_reg(to_integer(component_tx_transmitter_index_low + 1));
    component_tx_transmitter_dout(2) <= component_tx_transmitter_message_reg(to_integer(component_tx_transmitter_index_low + 2));
    component_tx_transmitter_dout(3) <= component_tx_transmitter_message_reg(to_integer(component_tx_transmitter_index_low + 3));
    component_tx_transmitter_dout(4) <= component_tx_transmitter_message_reg(to_integer(component_tx_transmitter_index_low + 4));
    component_tx_transmitter_dout(5) <= component_tx_transmitter_message_reg(to_integer(component_tx_transmitter_index_low + 5));
    component_tx_transmitter_dout(6) <= component_tx_transmitter_message_reg(to_integer(component_tx_transmitter_index_low + 6));
    component_tx_transmitter_dout(7) <= component_tx_transmitter_message_reg(to_integer(component_tx_transmitter_index_low + 7));
end process NEXYS4_COMPONENT_TX_TRANSMITTER_DOUT_LOGIC;



component_tx_transmitter_esc <= stdl((component_tx_transmitter_dout = spec_chr_start) or (component_tx_transmitter_dout = spec_chr_esc) or (component_tx_transmitter_dout = spec_chr_stop));



component_tx_transmitter_index_low <= resize(unsigned(((8 * spec_width_message_bytes) - signed(resize(resize(component_tx_transmitter_byte_count_reg, 5) * 8, 9))) - 8), 7);



exp_clk_en <= exp_clk_en_internal;

end architecture MyHDL;
